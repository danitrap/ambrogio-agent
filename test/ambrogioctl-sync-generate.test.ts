// test/ambrogioctl-sync-generate.test.ts
import { test, expect, beforeAll, afterAll } from "bun:test";
import { mkdir, rm, writeFile, chmod, readFile } from "node:fs/promises";
import path from "node:path";
import { runAmbrogioCtl } from "../src/cli/ambrogioctl";

const TEST_ROOT = path.join(import.meta.dir, "test-data-sync-generate");
const SKILLS_DIR = path.join(TEST_ROOT, "skills");
const OUTPUT_DIR = path.join(TEST_ROOT, "output");

beforeAll(async () => {
  await mkdir(SKILLS_DIR, { recursive: true });
  await mkdir(OUTPUT_DIR, { recursive: true });

  // Create working skill
  const skill1Path = path.join(SKILLS_DIR, "working-skill");
  await mkdir(skill1Path, { recursive: true });
  await mkdir(path.join(skill1Path, "scripts"), { recursive: true });

  await writeFile(
    path.join(skill1Path, "SYNC.json"),
    JSON.stringify({
      version: "1",
      outputFile: path.join(OUTPUT_DIR, "WORKING.md"),
      patterns: ["test:*"],
      generator: "./scripts/sync.sh",
    }),
  );

  const script1 = path.join(skill1Path, "scripts", "sync.sh");
  await writeFile(
    script1,
    `#!/usr/bin/env bash
set -euo pipefail
echo "# Generated by working-skill" > "$SYNC_OUTPUT_FILE"
echo "Patterns: $SYNC_PATTERNS" >> "$SYNC_OUTPUT_FILE"
echo "Synced successfully"
`,
  );
  await chmod(script1, 0o755);

  // Create failing skill
  const skill2Path = path.join(SKILLS_DIR, "failing-skill");
  await mkdir(skill2Path, { recursive: true });
  await mkdir(path.join(skill2Path, "scripts"), { recursive: true });

  await writeFile(
    path.join(skill2Path, "SYNC.json"),
    JSON.stringify({
      version: "1",
      outputFile: path.join(OUTPUT_DIR, "FAILING.md"),
      patterns: ["fail:*"],
      generator: "./scripts/sync.sh",
    }),
  );

  const script2 = path.join(skill2Path, "scripts", "sync.sh");
  await writeFile(script2, `#!/usr/bin/env bash\nexit 1`);
  await chmod(script2, 0o755);
});

afterAll(async () => {
  await rm(TEST_ROOT, { recursive: true, force: true });
});

test("sync generate --skill - generates output file", async () => {
  const outputs: string[] = [];

  const exitCode = await runAmbrogioCtl(
    ["sync", "generate", "--skill", "working-skill"],
    {
      socketPath: "/tmp/test.sock",
      stdout: (line) => outputs.push(line),
      stderr: () => {},
      env: { SKILLS_DIRS: SKILLS_DIR },
    },
  );

  expect(exitCode).toBe(0);
  expect(outputs.join("\n")).toContain("Synced successfully");

  const content = await readFile(path.join(OUTPUT_DIR, "WORKING.md"), "utf-8");
  expect(content).toContain("# Generated by working-skill");
  expect(content).toContain("Patterns: test:*");
});

test("sync generate --skill - handles generator failure", async () => {
  const errors: string[] = [];

  const exitCode = await runAmbrogioCtl(
    ["sync", "generate", "--skill", "failing-skill"],
    {
      socketPath: "/tmp/test.sock",
      stdout: () => {},
      stderr: (line) => errors.push(line),
      env: { SKILLS_DIRS: SKILLS_DIR },
    },
  );

  expect(exitCode).not.toBe(0);
  expect(errors.join("\n")).toContain("Failed");
});

test("sync generate --all - generates for all skills", async () => {
  const outputs: string[] = [];

  const exitCode = await runAmbrogioCtl(["sync", "generate", "--all"], {
    socketPath: "/tmp/test.sock",
    stdout: (line) => outputs.push(line),
    stderr: () => {},
    env: { SKILLS_DIRS: SKILLS_DIR },
  });

  // Should succeed even if one skill fails
  expect(exitCode).toBe(0);
  expect(outputs.join("\n")).toContain("working-skill");
  expect(outputs.join("\n")).toContain("failing-skill");
});

test("sync generate - requires --skill or --all", async () => {
  const errors: string[] = [];

  const exitCode = await runAmbrogioCtl(["sync", "generate"], {
    socketPath: "/tmp/test.sock",
    stdout: () => {},
    stderr: (line) => errors.push(line),
    env: { SKILLS_DIRS: SKILLS_DIR },
  });

  expect(exitCode).toBe(2);
  expect(errors.join("\n")).toContain("--skill or --all");
});
